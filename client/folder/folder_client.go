// Code generated by go-swagger; DO NOT EDIT.

package folder

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new folder API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for folder API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteUserFolderFolderID(params *DeleteUserFolderFolderIDParams) (*DeleteUserFolderFolderIDOK, error)

	GetFolderFolderID(params *GetFolderFolderIDParams) (*GetFolderFolderIDOK, error)

	GetUserFolder(params *GetUserFolderParams) (*GetUserFolderOK, error)

	PostUserFolder(params *PostUserFolderParams) (*PostUserFolderOK, error)

	PutUserFolderFolderID(params *PutUserFolderFolderIDParams) (*PutUserFolderFolderIDOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DeleteUserFolderFolderID deletes folder

  Deletes a folder.
*/
func (a *Client) DeleteUserFolderFolderID(params *DeleteUserFolderFolderIDParams) (*DeleteUserFolderFolderIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserFolderFolderIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteUserFolderFolderID",
		Method:             "DELETE",
		PathPattern:        "/user/folder/{folder_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserFolderFolderIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteUserFolderFolderIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteUserFolderFolderID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetFolderFolderID gets folder by id

  Returns all details of a specific folder including an array of all documents in that folder.

You can adjust the response produced by this endpoint using the following query parameters:

**filters=signing-status&filter-values** - allows to show documents with specific status
<br>allowed values: signed, pending, waiting-for-me, waiting-for-others

**filters=documents-created&filter-values** - shows documents that were created started from specific date (note: this filter is not applicable for Templates)
<br>allowed values: Unix timestamp

**filters=documents-updated&filter-values** - shows documents that were updated started from specific date (note: this filter is not applicable for Templates)
<br>allowed values: Unix timestamp

**sortby=created&order** - sorts documents by creation date in descending or ascending order
<br>allowed values: desc, asc

**sortby=updated&order** - sorts documents by update date
<br>allowed values: desc, asc

**limit** - displays specified number of documents; Max limit is 100. It means that if value of "limit" parameter exceeds 100, response is automatically limited to 100 documents.
<br>allowed values: integer

**offset** - displays documents from specified position
<br>allowed values: integer

**subfolder-data** - defines whether sub-folders of the given folder are displayed in the response. <br>allowed values: 1, 0 (i.e. subfolder-data=1)

**with_team_documents** - allows to display "Team Documents" folders.
<br>allowed values: true, false (i.e. with_team_documents=true)

**exclude_documents_relations** - allows to display short list of document info and increases maximum limit from 100 to 500 documents per page.
<br>allowed values: true, false (i.e. exclude_documents_relations=false)

The short list of document info is:

```
{
"id": " ",
"user_id": " ",
"document_name": " ",
"page_count": " ",
"created": " ",
"updated": " ",
"original_filename": " "
}
```
**include_documents_subfolders** - allows to hide sub-folders and display all documents from those sub-folders in the parent folder. Parameter works only for "Documents" and "Template" folder and their children. Default value - true
<br>allowed values: true, false



**exclude_documents_relations** - when this param is true, for documents in folder wonâ€™t include relations such as fields, signatures, etc, only the main info will be displayed.
<br>allowed values: true, false
*/
func (a *Client) GetFolderFolderID(params *GetFolderFolderIDParams) (*GetFolderFolderIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFolderFolderIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetFolderFolderID",
		Method:             "GET",
		PathPattern:        "/folder/{folder_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFolderFolderIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetFolderFolderIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetFolderFolderID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetUserFolder gets all folders

  Returns all folders of a user.
*/
func (a *Client) GetUserFolder(params *GetUserFolderParams) (*GetUserFolderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserFolderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUserFolder",
		Method:             "GET",
		PathPattern:        "/user/folder",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserFolderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetUserFolderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetUserFolder: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PostUserFolder creates folder

  Creates a folder for the user.
*/
func (a *Client) PostUserFolder(params *PostUserFolderParams) (*PostUserFolderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUserFolderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostUserFolder",
		Method:             "POST",
		PathPattern:        "/user/folder",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostUserFolderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PostUserFolderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostUserFolder: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PutUserFolderFolderID renames folder

  Renames a folder
*/
func (a *Client) PutUserFolderFolderID(params *PutUserFolderFolderIDParams) (*PutUserFolderFolderIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutUserFolderFolderIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutUserFolderFolderID",
		Method:             "PUT",
		PathPattern:        "/user/folder/{folder_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutUserFolderFolderIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutUserFolderFolderIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PutUserFolderFolderID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
